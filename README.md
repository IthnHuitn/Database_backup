# Домашнее задание к занятию "`Резервное копирование баз данных`" - `Ефимов Вячеслав`


### Инструкция по выполнению домашнего задания

   1. Сделайте `fork` данного репозитория к себе в Github и переименуйте его по названию или номеру занятия, например, https://github.com/имя-вашего-репозитория/git-hw или  https://github.com/имя-вашего-репозитория/7-1-ansible-hw).
   2. Выполните клонирование данного репозитория к себе на ПК с помощью команды `git clone`.
   3. Выполните домашнее задание и заполните у себя локально этот файл README.md:
      - впишите вверху название занятия и вашу фамилию и имя
      - в каждом задании добавьте решение в требуемом виде (текст/код/скриншоты/ссылка)
      - для корректного добавления скриншотов воспользуйтесь [инструкцией "Как вставить скриншот в шаблон с решением](https://github.com/netology-code/sys-pattern-homework/blob/main/screen-instruction.md)
      - при оформлении используйте возможности языка разметки md (коротко об этом можно посмотреть в [инструкции  по MarkDown](https://github.com/netology-code/sys-pattern-homework/blob/main/md-instruction.md))
   4. После завершения работы над домашним заданием сделайте коммит (`git commit -m "comment"`) и отправьте его на Github (`git push origin`);
   5. Для проверки домашнего задания преподавателем в личном кабинете прикрепите и отправьте ссылку на решение в виде md-файла в вашем Github.
   6. Любые вопросы по выполнению заданий спрашивайте в чате учебной группы и/или в разделе “Вопросы по заданию” в личном кабинете.
   
Желаем успехов в выполнении домашнего задания!
   
### Дополнительные материалы, которые могут быть полезны для выполнения задания

1. [Руководство по оформлению Markdown файлов](https://gist.github.com/Jekins/2bf2d0638163f1294637#Code)

---

### Задание 1

#### 1.1. Восстановление данных в полном объёме за предыдущий 

- Подходящий вариант: Ежедневное полное (Full) резервное копирование.

- Что это: Создание полной копии всей базы данных на момент окончания рабочего дня.

- Почему подходит: Процесс восстановления максимально прост и быстр — 
требуется развернуть только один резервный набор (бекап) за нужный день. 
Это обеспечивает именно тот уровень согласованности данных, 
который требуется — "состояние на конец предыдущего дня".

- Недостатки для этого кейса: При большом объёме данных полный бэкап может 
занимать много времени и ресурсов. Однако, поскольку требование — "за предыдущий день", 
а не "за последний час", этот метод идеально соответствует задаче.

- Практическая реализация: Бэкап запускается каждый день после окончания основных операций, 
например, в 23:00. Хранится несколько последних копий (на неделю или месяц).

#### 1.2. Восстановление данных за час до предполагаемой поломки

- Подходящий вариант: Комбинация полных и инкрементальных/дифференциальных копий, 
дополненная резервным копированием журналов транзакций (Transaction Log Backup).

- Для восстановления на произвольный момент времени (Point-in-Time Recovery) 
с точностью до часа необходима более сложная стратегия:

- Полный бэкап (Foundation): Выполняется, например, раз в неделю по воскресеньям. 
Это основа для восстановления.

- Инкрементальный (Incremental) или дифференциальный (Differential) бэкап: Выполняется ежедневно. 
Инкрементальный сохраняет изменения с последнего любого бэкапа, дифференциальный — с последнего полного. 
Это ускоряет ежедневное резервирование по сравнению с полным бэкапом.

- Ключевой элемент — Резервное копирование журналов транзакций (Transaction Log Backup): 
Выполняется каждые 30-60 минут. Журнал транзакций фиксирует все изменения в базе. 
Цепочка таких журналов позволяет "накатить" на последнюю полную+дифференциальную копию все транзакции, 
совершенные вплоть до конкретного момента времени.

##### Процесс восстановления в данном кейсе:

- Восстановить последний полный бэкап.

- Восстановить последний дифференциальный бэкап (если используется).

- Последовательно применить (восстановить) все резервные копии журналов транзакций, 
созданные после этого, остановившись на момоде "за час до поломки".

- Эта стратегия обеспечивает минимальную потерю данных (RPO ~1 час).

#### 1.3.* Моментальное переключение при поломке

Да, такой кейс возможен. Это реализуется решениями высокой доступности (High Availability, HA) 
и аварийного переключения (Disaster Recovery, DR).

Механизмы, обеспечивающие "моментальное" (на самом деле от нескольких секунд до минуты) переключение:

1. Репликация баз данных:

- Always On Availability Groups (SQL Server), Oracle Data Guard, Streaming Replication (PostgreSQL): 
Данные синхронно или асинхронно реплицируются с основного сервера (Primary) 
на один или несколько вторичных (Secondary). При отказе основного автоматически или 
вручную происходит переключение (failover) на вторичную реплику, 
которая становится новой основной базой. Для пользователей и приложений 
это выглядит как кратковременный сбой в соединении.

2. Кластеризация отказоустойчивости (Failover Clustering):

- Общее хранилище данных (SAN) используется несколькими узлами кластера. 
При падении активного узла кластер перезапускает службы СУБД на резервном узле, 
используя те же самые данные на диске. Переключение происходит быстро, 
но обычно требует общего хранилища, что является "единой точкой отказа".

3. Автоматическое восстановление с помощью резервных копий:

- Не является "моментальным" в прямом смысле, но может быть автоматизировано. 
Некоторые облачные и хостинговые решения (например, AWS RDS) позволяют автоматически 
создать новую инстанс базы данных из последней резервной копии в случае падения основной. 
Это занимает минуты или десятки минут, что для многих бизнес-процессов также приемлемо 
как "быстрое восстановление".

- Вывод для 1.3: Для моментального переключения используется не просто резервное копирование, 
а технологии репликации в реальном времени. Резервные копии в этом случае остаются 
важнейшим элементом защиты от логических ошибок (например, если ошибочная 
команда DELETE реплицируется на standby-сервер, нужна именно резервная копия, чтобы откатиться).

#### Итоговая рекомендация для компании:

- Для баланса надёжности, скорости восстановления и стоимости рекомендуется комбинированная стратегия:

- Для целей быстрого восстановления на произвольный момент (RPO ~15-60 мин): 
Использовать полные бэкапы еженедельно + дифференциальные ежедневно + копирование журналов транзакций 
каждые 15-60 минут.

- Для обеспечения высокой доступности и мгновенного переключения при сбое железа или ОС: 
Развернуть синхронную репликацию на standby-сервер в том же дата-центре (HA).

- Для защиты от катастрофы в дата-центре: Настроить асинхронную репликацию в удалённый дата-центр 
или облако (DR) и регулярно выгружать полные резервные копии в объектное хранилище с другой географией.

- Регулярно проводить учения по восстановлению из резервных копий, чтобы проверить их целостность и отработать процедуры.


---

### Задание 2

#### 2.1. Примеры команд резервного копирования и восстановления в PostgreSQL

- Резервное копирование с помощью pg_dump

1. Резервное копирование всей базы данных в файл:

```bash
pg_dump -U username -d database_name -f backup.sql
```

2. Резервное копирование в сжатый формат с собственным (custom) форматом PostgreSQL:

```bash
pg_dump -U username -d database_name -F c -f backup.dump
```

- -F c — формат вывода "custom" (сжатый, поддерживает параллельное восстановление)

- Такой формат может быть восстановлен только через pg_restore

3. Резервное копирование с детализацией:

```bash
pg_dump -U username -h localhost -p 5432 -d mydatabase \
  --clean --create --verbose --compress=9 \
  --file=mydatabase_backup_$(date +%Y%m%d).dump \
  --format=c
  ```

- --clean — добавляет команды DROP перед CREATE (удобно для полного пересоздания)

- --create — включает команду CREATE DATABASE

- --verbose — подробный вывод процесса

- --compress=9 — уровень сжатия (0-9)

- $(date +%Y%m%d) — добавляет дату к имени файла

4. Резервное копирование только схемы (без данных):

```bash
pg_dump -U username -d database_name --schema-only -f schema.sql
```

5. Резервное копирование только данных:

```bash
pg_dump -U username -d database_name --data-only -f data.sql
```

- Восстановление с помощью pg_restore

1. Восстановление из custom-формата:

```bash
pg_restore -U username -d database_name backup.dump
```

2. Восстановление в новую базу данных:

```bash
# Сначала создаем базу данных
createdb -U username new_database

# Восстанавливаем в нее
pg_restore -U username -d new_database backup.dump
```

3. Восстановление только структуры:

```bash
pg_restore -U username -d database_name --schema-only backup.dump
```

4. Восстановление с параллельным выполнением (ускоряет процесс):

```bash
pg_restore -U username -d database_name -j 4 backup.dump
```

- -j 4 — использует 4 параллельных потока

5. Восстановление из обычного SQL-файла:

```bash
psql -U username -d database_name -f backup.sql
```

#### 2.1.* Автоматизация процесса резервного копирования
- Да, автоматизировать процесс резервного копирования возможно и обязательно для production-среды.

1. Скрипты + планировщик заданий (cron)
Пример bash-скрипта для автоматического резервного копирования:

```bash
#!/bin/bash
# backup_postgres.sh

# Настройки
BACKUP_DIR="/var/backups/postgres"
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME="my_database"
USERNAME="postgres"
RETENTION_DAYS=7

# Создаем директорию для бэкапов, если её нет
mkdir -p $BACKUP_DIR

# Имя файла бэкапа
BACKUP_FILE="$BACKUP_DIR/${DB_NAME}_${DATE}.dump"

# Выполняем резервное копирование
echo "Начало резервного копирования $DB_NAME в $BACKUP_FILE"
pg_dump -U $USERNAME -d $DB_NAME -F c -f $BACKUP_FILE

# Проверяем успешность выполнения
if [ $? -eq 0 ]; then
    echo "Резервное копирование успешно завершено"
    
    # Удаляем старые бэкапы (старше RETENTION_DAYS дней)
    find $BACKUP_DIR -name "${DB_NAME}_*.dump" -mtime +$RETENTION_DAYS -delete
    echo "Удалены бэкапы старше $RETENTION_DAYS дней"
else
    echo "Ошибка при резервном копировании!"
    exit 1
fi
```

- Добавление в cron для ежедневного выполнения в 2:00:

```bash
0 2 * * * /path/to/backup_postgres.sh >> /var/log/postgres_backup.log 2>&1
```

2. Использование pgBackRest или Barman

- pgBackRest — профессиональное решение для резервного копирования PostgreSQL:

```bash
# Установка и настройка pgBackRest
# Конфигурационный файл /etc/pgbackrest.conf
[global]
repo1-path=/var/lib/pgbackrest
repo1-retention-full=2

[mycluster]
pg1-path=/var/lib/postgresql/16/main

# Создание полного бэкапа
pgbackrest --stanza=mycluster backup --type=full

# Автоматизация через cron
0 1 * * * pgbackrest --stanza=mycluster --type=incr backup
```

- Barman (Backup and Recovery Manager) — еще одно популярное решение:

```bash
# Резервное копирование
barman backup myserver

# Автоматическое управление ретеншеном
barman cron
```

3. Интеграция с облачными хранилищами
- Автоматическая выгрузка бэкапов в облако:

```bash
#!/bin/bash
# Создаем локальный бэкап
pg_dump -U postgres -d mydb -F c -f /tmp/backup.dump

# Загружаем в облако (пример для AWS S3)
aws s3 cp /tmp/backup.dump s3://my-backup-bucket/postgres/$(date +%Y%m%d).dump

# Очистка временных файлов
rm /tmp/backup.dump
```

4. Использование репликации + WAL-архивирование для Point-in-Time Recovery
- Настройка непрерывного архивирования WAL:

```postgresql
# В postgresql.conf
wal_level = replica
archive_mode = on
archive_command = 'cp %p /var/lib/postgresql/wal_archive/%f'
```

- Автоматический скрипт для PITR:

```bash
#!/bin/bash
# Автоматическое создание базовых бэкапов
BASE_BACKUP_DIR="/backups/base"
WAL_ARCHIVE_DIR="/backups/wal"

# Создаем базовый бэкап
pg_basebackup -D $BASE_BACKUP_DIR/$(date +%Y%m%d) -X fetch

# Архивируем WAL-файлы
find $WAL_ARCHIVE_DIR -name "*.backup" -mtime +30 -delete
```

#### Рекомендации по автоматизации:

1. Регулярное тестирование восстановления — минимум раз в квартал проверять, 
что бэкапы действительно восстанавливаются.

2. Многоуровневое хранение — хранить бэкапы в разных местах 
(локально, в облаке, в нескольких географических локациях ).

3. Ведение журналов — логировать все операции резервного копирования
 и восстановления.

4. Мониторинг — настроить алерты при пропуске бэкапов или ошибках.

5. Шифрование — шифровать бэкапы, особенно при хранении в облаке 
или выносе за пределы защищенного периметра.

#### Автоматизация резервного копирования PostgreSQL — это не просто удобство, а необходимое условие для обеспечения отказоустойчивости и соответствия требованиям бизнеса по доступности данных.


### Задание 3

`Приведите ответ в свободной форме........`

1. `Заполните здесь этапы выполнения, если требуется ....`
2. `Заполните здесь этапы выполнения, если требуется ....`
3. `Заполните здесь этапы выполнения, если требуется ....`
4. `Заполните здесь этапы выполнения, если требуется ....`
5. `Заполните здесь этапы выполнения, если требуется ....`
6. 

```
Поле для вставки кода...
....
....
....
....
```

`При необходимости прикрепитe сюда скриншоты
![Название скриншота](ссылка на скриншот)`

### Задание 4

`Приведите ответ в свободной форме........`

1. `Заполните здесь этапы выполнения, если требуется ....`
2. `Заполните здесь этапы выполнения, если требуется ....`
3. `Заполните здесь этапы выполнения, если требуется ....`
4. `Заполните здесь этапы выполнения, если требуется ....`
5. `Заполните здесь этапы выполнения, если требуется ....`
6. 

```
Поле для вставки кода...
....
....
....
....
```

`При необходимости прикрепитe сюда скриншоты
![Название скриншота](ссылка на скриншот)`
